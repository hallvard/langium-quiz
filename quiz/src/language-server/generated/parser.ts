/******************************************************************************
 * This file was generated by langium-cli 0.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
// @ts-nocheck
import { createToken, Lexer } from 'chevrotain';
import { LangiumParser, LangiumServices, DatatypeSymbol } from 'langium';
import { QuizGrammarAccess } from './grammar-access';
import { Answer, Option, OptionAnswer, OptionsAnswer, QA, Question, Quiz, QuizPart, SimpleAnswer, SingleOptionsAnswer, Xml, XmlAttribute, XmlContents, XmlElement, XmlTag, XmlAnswer, ManyOptionsAnswer, StringQuestion, XmlQuestion, BooleanAnswer, NumberAnswer, RegexAnswer, StringAnswer, SingleBoxOptionsAnswer, SingleListOptionsAnswer, XmlPIAnswerElement, XmlTagElement, } from './ast';

const ID = createToken({ name: 'ID', pattern: /[_a-zA-Z][\w_]*/ });
const INT = createToken({ name: 'INT', pattern: /[0-9]+/ });
const ML_COMMENT = createToken({ name: 'ML_COMMENT', pattern: /\/\*[\s\S]*?\*\//, group: Lexer.SKIPPED });
const SL_COMMENT = createToken({ name: 'SL_COMMENT', pattern: /\/\/[^\n\r]*/, group: Lexer.SKIPPED });
const STRING = createToken({ name: 'STRING', pattern: /"[^"]*"|'[^']*'/ });
const WS = createToken({ name: 'WS', pattern: /\s+/, group: Lexer.SKIPPED });
const XML_TEXT = createToken({ name: 'XML_TEXT', pattern: />(<|([^<>][^<]*<))/ });
const PartKeyword = createToken({ name: 'PartKeyword', pattern: /part/, longer_alt: ID });
const QuizKeyword = createToken({ name: 'QuizKeyword', pattern: /quiz/, longer_alt: ID });
const YesKeyword = createToken({ name: 'YesKeyword', pattern: /yes/, longer_alt: ID });
const LessThanLessThanKeyword = createToken({ name: 'LessThanLessThanKeyword', pattern: /<</, longer_alt: ID });
const MoreThanMoreThanKeyword = createToken({ name: 'MoreThanMoreThanKeyword', pattern: />>/, longer_alt: ID });
const NoKeyword = createToken({ name: 'NoKeyword', pattern: /no/, longer_alt: ID });
const BracketCloseKeyword = createToken({ name: 'BracketCloseKeyword', pattern: /\]/, longer_alt: ID });
const BracketOpenKeyword = createToken({ name: 'BracketOpenKeyword', pattern: /\[/, longer_alt: ID });
const DashKeyword = createToken({ name: 'DashKeyword', pattern: /-/, longer_alt: ID });
const EqualsKeyword = createToken({ name: 'EqualsKeyword', pattern: /=/, longer_alt: ID });
const ParenthesisCloseKeyword = createToken({ name: 'ParenthesisCloseKeyword', pattern: /\)/, longer_alt: ID });
const ParenthesisOpenKeyword = createToken({ name: 'ParenthesisOpenKeyword', pattern: /\(/, longer_alt: ID });
const QuestionMarkKeyword = createToken({ name: 'QuestionMarkKeyword', pattern: /\?/, longer_alt: ID });
const SlashKeyword = createToken({ name: 'SlashKeyword', pattern: /\//, longer_alt: ID });
const u126Keyword = createToken({ name: 'u126Keyword', pattern: /~/, longer_alt: ID });
const UnderscoreKeyword = createToken({ name: 'UnderscoreKeyword', pattern: /_/, longer_alt: ID });
const VKeyword = createToken({ name: 'VKeyword', pattern: /v/, longer_alt: ID });
const XKeyword = createToken({ name: 'XKeyword', pattern: /x/, longer_alt: ID });

UnderscoreKeyword.LABEL = "'_'";
DashKeyword.LABEL = "'-'";
QuestionMarkKeyword.LABEL = "'?'";
ParenthesisOpenKeyword.LABEL = "'('";
ParenthesisCloseKeyword.LABEL = "')'";
BracketOpenKeyword.LABEL = "'['";
BracketCloseKeyword.LABEL = "']'";
SlashKeyword.LABEL = "'/'";
LessThanLessThanKeyword.LABEL = "'<<'";
EqualsKeyword.LABEL = "'='";
MoreThanMoreThanKeyword.LABEL = "'>>'";
u126Keyword.LABEL = "'~'";
NoKeyword.LABEL = "'no'";
PartKeyword.LABEL = "'part'";
QuizKeyword.LABEL = "'quiz'";
VKeyword.LABEL = "'v'";
XKeyword.LABEL = "'x'";
YesKeyword.LABEL = "'yes'";
const tokens = [PartKeyword, QuizKeyword, YesKeyword, LessThanLessThanKeyword, MoreThanMoreThanKeyword, NoKeyword, BracketCloseKeyword, BracketOpenKeyword, DashKeyword, EqualsKeyword, ParenthesisCloseKeyword, ParenthesisOpenKeyword, QuestionMarkKeyword, SlashKeyword, u126Keyword, UnderscoreKeyword, VKeyword, XKeyword, ID, INT, ML_COMMENT, SL_COMMENT, STRING, WS, XML_TEXT];

export class Parser extends LangiumParser {
    readonly grammarAccess: QuizGrammarAccess;

    constructor(services: LangiumServices) {
        super(tokens, services);
    }

    Quiz = this.MAIN_RULE("Quiz", Quiz, () => {
        this.initializeElement(this.grammarAccess.Quiz);
        this.consume(1, QuizKeyword, this.grammarAccess.Quiz.QuizKeyword);
        this.option(1, () => {
            this.consume(2, ID, this.grammarAccess.Quiz.nameIDRuleCall);
        });
        this.consume(3, STRING, this.grammarAccess.Quiz.titleSTRINGRuleCall);
        this.many(1, () => {
            this.subrule(1, this.QuizPart, this.grammarAccess.Quiz.partsQuizPartRuleCall);
        });
        return this.construct();
    });

    QuizPart = this.DEFINE_RULE("QuizPart", QuizPart, () => {
        this.initializeElement(this.grammarAccess.QuizPart);
        this.consume(1, PartKeyword, this.grammarAccess.QuizPart.PartKeyword);
        this.option(1, () => {
            this.consume(2, ID, this.grammarAccess.QuizPart.nameIDRuleCall);
        });
        this.consume(3, STRING, this.grammarAccess.QuizPart.titleSTRINGRuleCall);
        this.many(1, () => {
            this.subrule(1, this.QA, this.grammarAccess.QuizPart.questionsQARuleCall);
        });
        return this.construct();
    });

    QA = this.DEFINE_RULE("QA", QA, () => {
        this.initializeElement(this.grammarAccess.QA);
        this.option(1, () => {
            this.consume(1, ID, this.grammarAccess.QA.nameIDRuleCall);
        });
        this.subrule(1, this.Question, this.grammarAccess.QA.qQuestionRuleCall);
        this.option(2, () => {
            this.consume(2, QuestionMarkKeyword, this.grammarAccess.QA.QuestionMarkKeyword);
        });
        this.subrule(2, this.Answer, this.grammarAccess.QA.aAnswerRuleCall);
        return this.construct();
    });

    Question = this.DEFINE_RULE("Question", Question, () => {
        this.initializeElement(this.grammarAccess.Question);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.StringQuestion, this.grammarAccess.Question.StringQuestionRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.XmlQuestion, this.grammarAccess.Question.XmlQuestionRuleCall);
            },
        ]);
        return this.construct();
    });

    StringQuestion = this.DEFINE_RULE("StringQuestion", StringQuestion, () => {
        this.initializeElement(this.grammarAccess.StringQuestion);
        this.consume(1, STRING, this.grammarAccess.StringQuestion.questionSTRINGRuleCall);
        return this.construct();
    });

    XmlQuestion = this.DEFINE_RULE("XmlQuestion", XmlQuestion, () => {
        this.initializeElement(this.grammarAccess.XmlQuestion);
        this.subrule(1, this.Xml, this.grammarAccess.XmlQuestion.xmlXmlRuleCall);
        return this.construct();
    });

    Answer = this.DEFINE_RULE("Answer", Answer, () => {
        this.initializeElement(this.grammarAccess.Answer);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.OptionAnswer, this.grammarAccess.Answer.OptionAnswerRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.OptionsAnswer, this.grammarAccess.Answer.OptionsAnswerRuleCall);
            },
        ]);
        return this.construct();
    });

    OptionAnswer = this.DEFINE_RULE("OptionAnswer", OptionAnswer, () => {
        this.initializeElement(this.grammarAccess.OptionAnswer);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.SimpleAnswer, this.grammarAccess.OptionAnswer.SimpleAnswerRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.XmlAnswer, this.grammarAccess.OptionAnswer.XmlAnswerRuleCall);
            },
        ]);
        return this.construct();
    });

    SimpleAnswer = this.DEFINE_RULE("SimpleAnswer", SimpleAnswer, () => {
        this.initializeElement(this.grammarAccess.SimpleAnswer);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.StringAnswer, this.grammarAccess.SimpleAnswer.StringAnswerRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.RegexAnswer, this.grammarAccess.SimpleAnswer.RegexAnswerRuleCall);
            },
            () => {
                this.unassignedSubrule(3, this.NumberAnswer, this.grammarAccess.SimpleAnswer.NumberAnswerRuleCall);
            },
            () => {
                this.unassignedSubrule(4, this.BooleanAnswer, this.grammarAccess.SimpleAnswer.BooleanAnswerRuleCall);
            },
        ]);
        return this.construct();
    });

    StringAnswer = this.DEFINE_RULE("StringAnswer", StringAnswer, () => {
        this.initializeElement(this.grammarAccess.StringAnswer);
        this.or(1, [
            () => {
                this.consume(1, ID, this.grammarAccess.StringAnswer.valueIDRuleCall);
            },
            () => {
                this.consume(2, STRING, this.grammarAccess.StringAnswer.valueSTRINGRuleCall);
            },
        ]);
        this.option(1, () => {
            this.consume(3, u126Keyword, this.grammarAccess.StringAnswer.u126Keyword);
        });
        this.option(2, () => {
            this.consume(4, UnderscoreKeyword, this.grammarAccess.StringAnswer.UnderscoreKeyword);
        });
        return this.construct();
    });

    RegexAnswer = this.DEFINE_RULE("RegexAnswer", RegexAnswer, () => {
        this.initializeElement(this.grammarAccess.RegexAnswer);
        this.consume(1, SlashKeyword, this.grammarAccess.RegexAnswer.SlashKeyword);
        this.consume(2, STRING, this.grammarAccess.RegexAnswer.valueSTRINGRuleCall);
        this.consume(3, SlashKeyword, this.grammarAccess.RegexAnswer.SlashKeyword);
        return this.construct();
    });

    NumberAnswer = this.DEFINE_RULE("NumberAnswer", NumberAnswer, () => {
        this.initializeElement(this.grammarAccess.NumberAnswer);
        this.consume(1, INT, this.grammarAccess.NumberAnswer.valueINTRuleCall);
        return this.construct();
    });

    BooleanAnswer = this.DEFINE_RULE("BooleanAnswer", BooleanAnswer, () => {
        this.initializeElement(this.grammarAccess.BooleanAnswer);
        this.action(BooleanAnswer, this.grammarAccess.BooleanAnswer.BooleanAnswerAction);
        this.or(1, [
            () => {
                this.consume(1, YesKeyword, this.grammarAccess.BooleanAnswer.YesKeyword);
            },
            () => {
                this.consume(2, NoKeyword, this.grammarAccess.BooleanAnswer.NoKeyword);
            },
        ]);
        return this.construct();
    });

    XmlAnswer = this.DEFINE_RULE("XmlAnswer", XmlAnswer, () => {
        this.initializeElement(this.grammarAccess.XmlAnswer);
        this.subrule(1, this.Xml, this.grammarAccess.XmlAnswer.xmlXmlRuleCall);
        return this.construct();
    });

    OptionsAnswer = this.DEFINE_RULE("OptionsAnswer", OptionsAnswer, () => {
        this.initializeElement(this.grammarAccess.OptionsAnswer);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.SingleOptionsAnswer, this.grammarAccess.OptionsAnswer.SingleOptionsAnswerRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.ManyOptionsAnswer, this.grammarAccess.OptionsAnswer.ManyOptionsAnswerRuleCall);
            },
        ]);
        return this.construct();
    });

    Option = this.DEFINE_RULE("Option", Option, () => {
        this.initializeElement(this.grammarAccess.Option);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.SingleBoxOption, this.grammarAccess.Option.SingleBoxOptionRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.SingleListOption, this.grammarAccess.Option.SingleListOptionRuleCall);
            },
            () => {
                this.unassignedSubrule(3, this.ManyOption, this.grammarAccess.Option.ManyOptionRuleCall);
            },
        ]);
        return this.construct();
    });

    SingleOptionsAnswer = this.DEFINE_RULE("SingleOptionsAnswer", SingleOptionsAnswer, () => {
        this.initializeElement(this.grammarAccess.SingleOptionsAnswer);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.SingleBoxOptionsAnswer, this.grammarAccess.SingleOptionsAnswer.SingleBoxOptionsAnswerRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.SingleListOptionsAnswer, this.grammarAccess.SingleOptionsAnswer.SingleListOptionsAnswerRuleCall);
            },
        ]);
        return this.construct();
    });

    SingleBoxOptionsAnswer = this.DEFINE_RULE("SingleBoxOptionsAnswer", SingleBoxOptionsAnswer, () => {
        this.initializeElement(this.grammarAccess.SingleBoxOptionsAnswer);
        this.atLeastOne(1, () => {
            this.subrule(1, this.SingleBoxOption, this.grammarAccess.SingleBoxOptionsAnswer.optionsSingleBoxOptionRuleCall);
        });
        return this.construct();
    });

    SingleBoxOption = this.DEFINE_RULE("SingleBoxOption", Option, () => {
        this.initializeElement(this.grammarAccess.SingleBoxOption);
        this.or(1, [
            () => {
                this.consume(1, ParenthesisOpenKeyword, this.grammarAccess.SingleBoxOption.ParenthesisOpenKeyword);
                this.option(1, () => {
                    this.consume(2, DashKeyword, this.grammarAccess.SingleBoxOption.DashKeyword);
                });
            },
            () => {
                this.option(2, () => {
                    this.or(2, [
                        () => {
                            this.consume(3, XKeyword, this.grammarAccess.SingleBoxOption.XKeyword);
                        },
                        () => {
                            this.consume(4, VKeyword, this.grammarAccess.SingleBoxOption.VKeyword);
                        },
                    ]);
                });
                this.consume(5, ParenthesisCloseKeyword, this.grammarAccess.SingleBoxOption.ParenthesisCloseKeyword);
                this.subrule(1, this.OptionAnswer, this.grammarAccess.SingleBoxOption.optionOptionAnswerRuleCall);
            },
        ]);
        return this.construct();
    });

    SingleListOptionsAnswer = this.DEFINE_RULE("SingleListOptionsAnswer", SingleListOptionsAnswer, () => {
        this.initializeElement(this.grammarAccess.SingleListOptionsAnswer);
        this.atLeastOne(1, () => {
            this.subrule(1, this.SingleListOption, this.grammarAccess.SingleListOptionsAnswer.optionsSingleListOptionRuleCall);
        });
        return this.construct();
    });

    SingleListOption = this.DEFINE_RULE("SingleListOption", Option, () => {
        this.initializeElement(this.grammarAccess.SingleListOption);
        this.or(1, [
            () => {
                this.consume(1, DashKeyword, this.grammarAccess.SingleListOption.DashKeyword);
            },
            () => {
                this.or(2, [
                    () => {
                        this.consume(2, XKeyword, this.grammarAccess.SingleListOption.XKeyword);
                    },
                    () => {
                        this.consume(3, VKeyword, this.grammarAccess.SingleListOption.VKeyword);
                    },
                ]);
            },
        ]);
        this.subrule(1, this.OptionAnswer, this.grammarAccess.SingleListOption.optionOptionAnswerRuleCall);
        return this.construct();
    });

    ManyOptionsAnswer = this.DEFINE_RULE("ManyOptionsAnswer", ManyOptionsAnswer, () => {
        this.initializeElement(this.grammarAccess.ManyOptionsAnswer);
        this.atLeastOne(1, () => {
            this.subrule(1, this.ManyOption, this.grammarAccess.ManyOptionsAnswer.optionsManyOptionRuleCall);
        });
        return this.construct();
    });

    ManyOption = this.DEFINE_RULE("ManyOption", Option, () => {
        this.initializeElement(this.grammarAccess.ManyOption);
        this.or(1, [
            () => {
                this.consume(1, BracketOpenKeyword, this.grammarAccess.ManyOption.BracketOpenKeyword);
                this.option(1, () => {
                    this.consume(2, DashKeyword, this.grammarAccess.ManyOption.DashKeyword);
                });
            },
            () => {
                this.option(2, () => {
                    this.or(2, [
                        () => {
                            this.consume(3, XKeyword, this.grammarAccess.ManyOption.XKeyword);
                        },
                        () => {
                            this.consume(4, VKeyword, this.grammarAccess.ManyOption.VKeyword);
                        },
                    ]);
                });
                this.consume(5, BracketCloseKeyword, this.grammarAccess.ManyOption.BracketCloseKeyword);
                this.subrule(1, this.OptionAnswer, this.grammarAccess.ManyOption.optionOptionAnswerRuleCall);
            },
        ]);
        return this.construct();
    });

    Xml = this.DEFINE_RULE("Xml", Xml, () => {
        this.initializeElement(this.grammarAccess.Xml);
        this.consume(1, LessThanLessThanKeyword, this.grammarAccess.Xml.LessThanLessThanKeyword);
        this.subrule(1, this.XmlElement, this.grammarAccess.Xml.elementXmlElementRuleCall);
        this.consume(2, MoreThanMoreThanKeyword, this.grammarAccess.Xml.MoreThanMoreThanKeyword);
        return this.construct();
    });

    XmlContents = this.DEFINE_RULE("XmlContents", XmlContents, () => {
        this.initializeElement(this.grammarAccess.XmlContents);
        this.subrule(1, this.XmlElement, this.grammarAccess.XmlContents.elementXmlElementRuleCall);
        this.consume(1, XML_TEXT, this.grammarAccess.XmlContents.postXML_TEXTRuleCall);
        return this.construct();
    });

    XmlElement = this.DEFINE_RULE("XmlElement", XmlElement, () => {
        this.initializeElement(this.grammarAccess.XmlElement);
        this.or(1, [
            () => {
                this.unassignedSubrule(1, this.XmlPIAnswerElement, this.grammarAccess.XmlElement.XmlPIAnswerElementRuleCall);
            },
            () => {
                this.unassignedSubrule(2, this.XmlTagElement, this.grammarAccess.XmlElement.XmlTagElementRuleCall);
            },
        ]);
        return this.construct();
    });

    XmlPIAnswerElement = this.DEFINE_RULE("XmlPIAnswerElement", XmlPIAnswerElement, () => {
        this.initializeElement(this.grammarAccess.XmlPIAnswerElement);
        this.consume(1, QuestionMarkKeyword, this.grammarAccess.XmlPIAnswerElement.QuestionMarkKeyword);
        this.subrule(1, this.SimpleAnswer, this.grammarAccess.XmlPIAnswerElement.answerSimpleAnswerRuleCall);
        this.consume(2, QuestionMarkKeyword, this.grammarAccess.XmlPIAnswerElement.QuestionMarkKeyword);
        return this.construct();
    });

    XmlTagElement = this.DEFINE_RULE("XmlTagElement", XmlTagElement, () => {
        this.initializeElement(this.grammarAccess.XmlTagElement);
        this.subrule(1, this.XmlTag, this.grammarAccess.XmlTagElement.startTagXmlTagRuleCall);
        this.or(1, [
            () => {
                this.consume(1, SlashKeyword, this.grammarAccess.XmlTagElement.SlashKeyword);
            },
            () => {
                this.consume(2, XML_TEXT, this.grammarAccess.XmlTagElement.preXML_TEXTRuleCall);
                this.many(1, () => {
                    this.subrule(2, this.XmlContents, this.grammarAccess.XmlTagElement.contentsXmlContentsRuleCall);
                });
                this.consume(3, SlashKeyword, this.grammarAccess.XmlTagElement.SlashKeyword);
                this.consume(4, ID, this.grammarAccess.XmlTagElement.endTagIDRuleCall);
            },
        ]);
        return this.construct();
    });

    XmlTag = this.DEFINE_RULE("XmlTag", XmlTag, () => {
        this.initializeElement(this.grammarAccess.XmlTag);
        this.consume(1, ID, this.grammarAccess.XmlTag.nameIDRuleCall);
        this.many(1, () => {
            this.subrule(1, this.XmlAttribute, this.grammarAccess.XmlTag.attributesXmlAttributeRuleCall);
        });
        return this.construct();
    });

    XmlAttribute = this.DEFINE_RULE("XmlAttribute", XmlAttribute, () => {
        this.initializeElement(this.grammarAccess.XmlAttribute);
        this.consume(1, ID, this.grammarAccess.XmlAttribute.nameIDRuleCall);
        this.consume(2, EqualsKeyword, this.grammarAccess.XmlAttribute.EqualsKeyword);
        this.consume(3, STRING, this.grammarAccess.XmlAttribute.valueSTRINGRuleCall);
        return this.construct();
    });

}
